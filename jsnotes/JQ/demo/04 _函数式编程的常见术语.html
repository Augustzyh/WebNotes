<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>40-js</title>
  <style>
    *{margin:0;padding:0;}
    
  </style>
</head>
<body>
  <script>
    /* 
      抖音ID：tanzhou_fengyu

      纯函数
      偏函数
      柯里化函数
      反柯里化：

      高阶函数：能接受函数作为参数，同时返回值可以是函数的函数

      防抖函数
      节流函数

      数组扁平化：把一个多维数组降维
    */  
    
    
    // 纯函数
    /* 
      概念：相同的输入，永远得到相同输出。不能改变外界的状态
    */
    
    /* 
      偏函数: partial
        概念：固定一个函数的一个或者多个参数，然后返回一个新函数，返回入参函数的剩余函数的接受应用
    */
    
    /* 
      柯里化函数: currying

      概念：把一个多参（n）函数转n个单参数函数

      目的：为了缩小适用范围，创建一个针对性更强的函数
      优点：复用性，延迟计算
    */

    // function add(){
    //   let res = 0
    //   for (let i = 0; i < arguments.length; i++){
    //     res += arguments[i]
    //   }
    //   return res
    // }

    //add(1,2,3,4,5)
    // 柯里化的基础版
    // function curry(fn){
    //   var args = [].slice.call(arguments, 1)
    //   return function(){
    //     var newArgs = args.concat([].slice.call(arguments))
    //     return fn.apply(null, newArgs)
    //   }
    // }


    // 完整版的柯里化
    // function curry(fn, minArg){
    //   if(minArg === undefined) minArg = 1
      
    //   function f(fArg){
    //     return function(){
    //       var arg = [].slice.call(arguments)
    //       var newArg = fArg.concat(arg)
    //       if(newArg.length >= minArg){
    //         return fn.apply(null, newArg)
    //       }else{
    //         return f(newArg)
    //       }
    //     }
    //   }
    //   return f([])
    // }

    // const fn = curry(add, 5)


    // const f = fn(1)()(3)

    // console.log(f(4)(5)()(6))
    
      
    Function.prototype.uncurry = function(){
      var that = this
      return function(){
        Array.prototype.push.call.apply(that, arguments)
      }
    }
    
    const push = Array.prototype.push.uncurry()
    
    const arr = []
    const obj = {}

    push(obj, "a")

    console.log(obj)

    


  </script>
</body>
</html>