# 18期H5课程



# 第一节课

## 通告

​	致力于让大家学到更多技术及减少学习成本，课程内容不断调整和升级，所以今后课程三H5，不再讲课程一的CSS3部分只，只讲`高级部分`及`新增内容`，如果想复习CSS3部分可以去论坛下载之前视频复习。

​	课程每一次调整都是为了让大家更好更快就业，所以每一期H5特色会有所不同！祝大家学习有成！

## 开发工具

```
电脑配置中高以上: 新买电脑2500以上
	webstorm英文 / phpstorm英文
	atom英文
	Hbuilder中文
	vscode 中文
	nodepade ++ 英文
	sublime text3 中文
电脑配置低:
	editplus 中文

开发工具都可以免费体验
开发前端安装一、二个工具即可 ，专精一个就可
```



## H5特点

```
H5注重用户体验，而不专注特效
	H5的难点在于兼容性，高级api超前会有各种限制
    学技术要举一反三，融会贯通
    在于理解，不要刻意记忆，记不住，多练习
    H5肯定不兼容 IE678 IE10 IE11（拖后腿） 不要强求兼容IE 
    特性利于用户、开发者，更加方便
    学东西侧重点，有目的性学习，贪多嚼不乱
 	理解每个知识点、作用、应用
 	去多看，才能丰富知识库，开阔视野
 	有目的性
 	决心 不要给自己留退路
 	不管学到什么知识 一定要结合实战
 	vue react 开发环境源码 本质 
 	
```



**课程一： CSS3部分**

```

《注重布局+样式+动画》
    1. H5新标签
        布局 + 都有特殊的含义 + seo非常友好
    2. 新选择器
        传统的找到某个元素 添加class类名, 基本布局+整体布局+ui界面+功能性+继承
    3. 背景属性
        元素颜色表示方法
    4. 文本属性
        修饰文本的样式
    5. 过渡和自定义动画
        重点
        大部分的动画都会用 transition
        通过添加class类名方式 运行自定义动画
    6. 2D和3D变换
        重点
        就是实现动画的
        开拓你的视野，丰富你的想象力
        多看别人的成果，总结技巧
    7. 智能表单
        很多的控件，时间、日历、数字键盘。。。
    8. 响应式
        根据屏幕的宽度不同，而显示不同的布局的结构
        非常麻烦，大小、排版（ui设计师图，都会根据实际用户需求，不会让你凭空想象）
        不能引入到app里面，因为结构非常乱、代码累赘、不好维护
        bootstrap 封装很多类 类库 里面有提供UI组件库
    9. 弹性盒子模型
        重点 属性非常多 不需要刻意记
        只有几个属性常见
        在移动端应用很多 简单方便，兼容还行
```



## H5部分

```
二阶段： H5高级部分注重功能实现
    10. 拖拽
            根据鼠标的移动位置，让元素联动
            H5拖拽 获取元素的名字、文件大小、时间。。。
    11. 历史管理-新增方法
            浏览器里面是有自带的后退+前进按钮+刷新
            app里面没有，用元素模拟的 go(-1 1 0)
            引入jq addClass removeClass toggleClass
            H5有提供方法 add() remove...
    12. 地理位置信息
            原生ApI由于涉及用户的隐私，不太支持
            基于平台或sdk 程序开发包
            都是基于百度地图、高德地图、腾讯地图 API 可以Ip地址、详细地址、经纬度
            可以根据 ip 获取 详细地址
            可以根据 经纬度获取 详细地址
            ip 网络运营商提供
    13. ajax上传
        	数据交互，后端接口搭建，上传文件
    14. 本地存储-多线程-离线存储
            cookie 封装 存 取 删掉
            H5有提供方法 setData getData removeData clear()
    15. 多媒体
            用来播放音视频
            H5有提供一些基本的属性和方法
            web audio api 提供很多的一些高级Api 如果把音视频研究透 都各大互联网或平台抢着要你
            需要对数学算法 + 音乐常识
    16. canvas
            绘图
            位图 矢量图
            非常不切实际的效果
            游戏
            图表 大数据 可视化图形显示界面
            真实应用会依赖第三方插件 echarts highecharts
	17. svg (删除)
			参考15期svg
			真实应用会依赖第三方插件 echarts highecharts
```



## 历史课程

```javascript
数据编码解码及历史管理

	H5多文件上传

	H5本地存储-离线存储-web多线程-server

	canvas特效

	移动端项目适配方案

	原生JS封装移动端网页轮播图上下滑屏特效插件    12期实战

	原生JS封装插件Android/IOS移动端手势操作插件  12期实战

	获取用户地理位置应用、百度地图 / 高德地图API应用    16期

	echarts / highcharts 高级图表应用     10期 canvas后面

	前端网页跨服务器和PHP后端数据交互   16期 17期

	整个网站项目打包Android APP    12期实战	17期实战

	动态音乐播放器Android APP开发      13期最后一节

	ajax上传调取摄像头摄像、拍摄、语音的资源     	17期 ajax

	模拟视频直播系统、拍照、下载、水印、美颜    	 17期底层核心API 

	Ajax2请求多媒体资源、播放、变声、封装音频音波图  	17期底层核心API 

	3D真实环绕音效 	17期底层核心API 

	语音识别、文字播报成语音，语音翻译成文字  17期底层核心API 

	真实webSocket多人聊天室功能	17期底层核心API 

	网页版真实闹铃功能	17期底层核心API 

	重力感应与陀螺仪应用	17期底层核心API 

	阿里云Linux服务器node环境配置		18期实战

	阿里云Linux服务器php运行环境配置  	18期实战

	企业级Vue项目实战开发		18期实战



	视频在论坛 vip H5版块

```



## 移动端适配

​	3种适配方案，让网页完美显示在移动



## 18期H5特色 VUE实战

​	

开发项目

​	产品经理 需求分析

​	研发部门开发

​		数据先行

​	测试部门测试

​		白盒 黑盒

​	运维部门 部署

​		服务器



每一期用一个框架，搭建后台数据接口，模拟真实开发环境开发项目。



*本期运用企业级Vue2实战项目开发*

vue-cli

1、Node环境安装
2、webpack项目部署及vue-cli脚手架项目搭建

3、认识vue
4、vue常用指令
5、Vue事件处理器
6、vue生命周期
7、vue组建及组建间通讯
8、vue核心插件运用：
​        vue-router路由系统
​        axios数据交互
​        vuex状态管理
9、vue UI组件库



## 阿里云空间配置

​	`虚机主机配置 开通php语言运行环境`

​	`ECS服务器Node运行环境搭建`

​	`ECS服务器apache环境配置`





##全栈江湖

​	[全栈江湖](http://web.tanzhouedu.com/index/course-intro/)

## H5知识点大纲

​	[H5知识点大纲](http://web.tanzhouedu.com/index/xc_H5.html)



## 拓展分享



+ 查看谷歌版本[win10](C:\Users\MACHENIKE\AppData\Local\Google\Chrome\User Data\Default\Extensions)

> 地址栏输入chrome:version



[JS模块规范](https://segmentfault.com/a/1190000012419990)



```shell
npm install -g vue-cli
vue init webpack vue-project
cd vue-project
npm i
npm run dev
```





```javascript
问题：
        1. 大概多久学完
            2个月
        2. 行业工资不能说，经验几年过万
            前端很多学完全部课程（课程一二三+框架） 月薪都过万
        3. 学完能找到对象吗
            new
        4. 框架要都学完吗
            学完 node vue bootstrap就可以开心找工作了，每个公司需求不太一样
        5. 老师是不是讲过微信公众平台
            没有，只讲过基于微信开发微网站
        6. 找工作，把你的所学体现出来
            简历，找工作前找心艾老师获取一份免费的职业分享课程
            人际关系有 简历+面试技巧课程，只要499
        7. 一些项目要在服务器环境运行
            服务器很便宜 淘宝几块钱一台，大学生可以申请免费阿里云虚拟主机或服务器
        8. 服务器和虚拟主机
            【服务器】相当于一台电脑：
                cpu 1234核
                内存 1234G
                系统 window/ linux
                硬盘 40G
                想安装都可以
                【适合用开发经验的人使用】
                需要配置
                要学linux

            【虚拟主机】相当于一台电脑里面的文件夹：
                想像一台电脑有多少文件夹？
                window / linux
                最重要的就是：
                    操作简单
                    即买即用（肯定需要备案，备案最快15天，国外的主机免备案）
                    安装不了其他软件
                【适合萌新使用】
        9.  网站上线要具备哪些
            要买域名和服务器或虚拟主机，通过ftp
            域名要备案


        10. 讲bootstrap吗
            bootstrap是属于框架班级，框架班极有视频
        11. 您的微信微网站开发视频还有吗，想学学
            13期实战，需要有后端开发经验，否则文档都看不懂，
            个人申请的微信公众号好像只能开订阅号，开不了服务号
        12. 我看过一篇文章说h5开发的项目修改可以不用修改源码，但是没讲为什么，我没理解是什么意思
            比如VUE，不能修改，正常情况下没有用框架 ，那是可以修改的，核心就是原理要弄懂
        13. 让我做反爬虫这个合理吗
            如果你是做Node开发，那肯定要爬数据，然后存到文件里、
        14. 会交微信小程序
            已经讲了好几期，可以找心艾老师
        15. 老师，你会经常复习之前学过的知识吗、感觉学不完，还老忘记旧知识
            会 任何人不复习都会忘,
        16. 学完h5再学vue.js好找工作吗
            现在薪资高一些，都会要求 要掌握 一二种框架
            node vue
        17. 在北京，像我们这刚学完，但还不是很熟悉的，工资大概能拿多少呢
        18. 微信公众号高级一些的开发需要掌握什么知识？
                php java python node .net
        还有很大的提升空间
        8小时内求生存，8小时外求发展
        在8小时外求发展外，干了哪些事情？？？
            在IT行业，每年必须有要新规划和目标
            用技术吃饭，肯定全方面的提升技术
        19. 微信公众号和移动端H5不一样吗
            不一样的，有后端开发经验作支持的
            
            
```







### 1. 浏览器插件安装



> 谷歌右上角设置 -> 更多工具 -> 拓展程序 -> 开打开发者模式
>
> 加载已拓展的程序 -> 选择 插件 版本 1.0.0 -> 一一导入





## 2. 安装有道翻译

​	[有道官网](http://cidian.youdao.com/)



# 3. 安装node

去官网下载最新版本 10.4.0



## 4. 工发工具



自己去官网下载



## 5. PS



建议 PSCC版本



## 6. Typora记录笔记工具 

[Typora下载地址](https://www.typora.io/)



## 7. git安装

[git下载地址](https://git-scm.com/download/win)





# 第二节课



### 【虚拟主机】【服务器】环境搭建及配置



### 1.为什么要买 虚假主机或服务器呢？



- 为了增加真实开发经验
- 做的项目上传到服务器里面，让任何人都能够通过域名或ip 访问
- 还有很多好处，以后自行体验



## 2. 建议在阿里云官网购买

​	登录或注册 阿里云 官网 

## 3. 域名 



域名是用来 访问服务器里面某个项目（html,php,jsp，asp）

注册域名，随意取名，好听单词基本都被注册了，买`.com`域名

尽量地 取个有个性单词（域名）

不建议用中文名字，会出现编码问题

想的好的名字都注册，如果不介意的话，可以买个 `.cn`

加入清单，直接购买



### 4. 虚拟主机

​	

​	也是用来存放 项目（html,php,asp）

​	有限制：不能安装软件比如： node..   傻瓜式使用

​	相当于一台电脑里文件夹

​	【不要买国外的，速度很慢】

​	运行系统是可以随意切换的 windows linux

​	是固定，买的时候是什么环境就是什么环境，不能安装其他软件

 + 虚拟主机
   + 一般是用来搭建博客做SEO，看用途
     + dede cms 织梦
     + wordpress cms
     + 帝国cms
     + hexo和 github
     + ...

环境选择支持 PHP 5.2/5.3/5.4/5.5/7.0/7.1、HTML、WAP

给钱就能拥有一切



	### 5. 云服务器

​	优惠拉链： https://promotion.aliyun.com/ntms/act/group/team.html?group=uVKuaGdnl4

​	也是用来 部署项目的（html,jsp,asp,php,py...）

​	安装啥软件都可以的，可拓展

​	挺贵的，建议在有活动的时候购买

​	即买即用，不需要备案，因为有提供独立ip

​	通过ip访问服务器里面的项目

是新用户：

+ 之前没有购买阿里云的产品
+ 自己要不要 根据自身实际情况，不强求
+ ​



### 6. 虚拟主机的配置及环境搭建



+ 登录阿里云官网
+ 进入控制台
+ 网页左侧导航展开
+ 进入云虚拟主机
+ 管理
+ 确认 支持linux  语言是 php
+ 如果是windows系统要切换成linux系统，免费切换
+ 上面步骤完成之后，下面
  + 域名绑定去虚拟主机 
  + 虚拟主机绑定域名

> 因为是通过域名访问虚拟主机里的项目（网页)

+ 1.域名绑定


+ 记录类型 A
+ 主机记录  写或不写www  
  + www
  + @
+ 记录值 ，是你买虚拟主机的ip



+ 2. 虚拟主机
     + 管理
     + 域名管理
     + 绑定域名 （由于我们是在阿里云官网购买的域名，所以直接选择您账户下的万网域名就可

+ 3. 开二级域名

     1. 一样的

     2. 主机记录

        new.baidu.com

        tb.baidu.com

+ 刚刚开的 二级域名 也是绑定到同一台虚拟主机，所以这些域名都指向同一台虚拟主机同一个项目

+ 没有端口 默认80端口

+ 不能指向这台虚拟主机里的另外的项目



### 7. 虚拟主机上传



 + 下载上传软件

[filezilla去官网下载](https://filezilla-project.org/)

[8uftp]()

 + 注意 虚拟主机用 8uftp	
 + 如果用filezilla 里面的中文文件会出现乱码
+ 8utfp新建站点
  + 进入虚拟主机的站点信息
  + 主机名 
    + FTP登录主机地址
  + 服务器类型FTP
  + 用户名 
    + FTP登录用户名：
  + 密码 不告诉你
  + 连接
  + 把你做的项目（html）打包上传到 `htdocs` 里面
  + 因为一个项目可能有很多很多图片及其他资源，不压缩及其的慢
  + 虚拟主机linux压缩格式是 linux支持zip和tar，windows支持zip和rar。
  + 在文件管理 文件解压 进入解压文件
  + 然后就可以用域名访问目录   xxx.com/3d

### 8.域名需要备案

​	只需要进入备案专区 

​	按照流程来，很简单，官方有流程图，就可备案成功

​	备案成功的时间大概 最快的15天左右，慢的话一个月

​	【备案通过了，才能够用域名访问虚拟主机的项目】

​	

### 9. ECS云服务器配置及环境



 + 控制台 左侧导航 
 + 进入云服务器ECS
+ 进入实例
  + 选择你当时购买的服务器机房
+ 管理
  + 停止（关机）
  + 才能切换系统
+ 更多操作 
  + 更换系统盘
+ 公共镜像
  + centOS 7.2 64
+ 设置密码
  + 大家字母 + 小写字母 + 数字
  + 尽量取个简单点，方便记
+ ​
+ 系统启动成功完成之后，所有配置都是在命令行中操作
+ putty软件连接 ECS服务器
  + ip 
    + 公用ip
  + 端口 
    + 22
  + 连接类型
    + ssh
  + 登录
    + 第一次会生成密钥
    + 自己个人电脑 是
    + 公用电脑否
  + putty命令行
    + root
    + 密码 （切换系统的时候设置的密码）
    + 输入的时候没有提供，直接输入
    + 就能进入服务器
  + 远程连接
    + 第一次会须须弹窗 让你记录下密码，很重要，保存到电脑上，会经常用到

## 10.node环境搭建



正常基本2分钟就能搭建完成 

+ 命令
+ cd /      进入根目录
+ ls         查看目录 
+ ls -ls
+ clear    清除
+ cd /usr/local/src
+ wget  nodejs链接   下载
  + 百度nodejs中文网
  + 下载
  + 用阿里云镜像
  + wget https://nodejs.org/dist/v10.3.0/node-v10.3.0-linux-x64.tar.gz
  + ctrl + c 终止
  + rm -rf 

```shell
tab键可以补全文件或路径名
进入指定目录
cd /usr/local/src/
下载资源（淘宝镜像 .gz后缀文件）
wget https://nodejs.org/dist/v10.3.0/node-v10.3.0-linux-x64.tar.gz
下载完成后,执行解压命令
tar xvf node-v8.11.1-linux-x64.tar.gz
删掉文件
rm -rf 文件名
cd node-v8.11.1-linux-x64/bin
查看文件，会看到 node npm 
ls 
设置全局,在任何目录都可能运行 node 和 npm 命令
ln -s /usr/local/src/node-v10.3.0-linux-x64/bin/node /usr/local/bin/node 
ln -s /usr/local/src/node-v10.3.0-linux-x64/bin/npm /usr/local/bin/npm 
ln -s /usr/local/src/node-v10.3.0-linux-x64/bin/cnpm /usr/local/bin/cnpm 
ln -s /usr/local/src/node-v10.3.0-linux-x64/bin/pm2 /usr/local/bin/pm2 

因为个别同学服务器地区问题原因，全局变量配置不成功，就配置到 /bin/下面
ln -s /usr/local/src/node-v10.3.0-linux-x64/bin/node /bin/node 
ln -s /usr/local/src/node-v10.3.0-linux-x64/bin/npm /bin/npm
ln -s /usr/local/src/node-v10.3.0-linux-x64/bin/cnpm /bin/cnpm 
ln -s /usr/local/src/node-v10.3.0-linux-x64/bin/pm2 /bin/pm2 
```



+ 利用filezilla上传项目
+ 主机
  + 公网ip
+ 端口
  + 22
+ 协议
  + ssh
+ 登录类型
  + 正常
+ 用户名
  + root
+ 密码 不告诉你
+ 如果通行命令行的形式下载 node压缩包不成功（由于网络慢或其他原因）
  + 可以在nodejs中文网直接点击 node-v10.3.0-linux-x64.tar.gz 下载到电脑 包  通过filezilla上传到 `/usr/local/src` 里

  + 上传完成之后用命令行解压

    ​

  ​

+ cd /usr/local/src
+ ls
+ tar xvf node包名称
+ cd node...文件夹
+ ls
+ cd bin
+ ./node 
  + 10.3.0
+ 因为我们要在任何目录都能执行node和npm命令，所以要配置全局变量
  + ln -s /usr/local/src/node...../bin/node /usr/local/bin/node
  + ln -s /usr/local/src/node...../bin/npm /usr/local/bin/npm
  + 此时在任何目录下，就行运行node和npm命令了
  + cd /
  + node -v
  + npm -v
  + 把安装过的包删掉
    + cd /usr/local/src
    + ls
    + rm -rf 包名
    + ​
+ 写一个js
+ 找一个node项目用node运行起来
+ 然后通过公网ip的形式访问，会发现访问不了，原因是没有开放端口


#### 11. 安全组开放访问端口

+ 进入实例
+ 安全组
+ 配置规则
+ 添加安全规则
+ 协议类型 TCP
  + 80/80
  + 6000/9999
  + 443/443
+ 协议类型 HTTP/HTTPS
  + 80/80
+ 授权类型：地址段访问
+ 授权对象
  + 0.0.0.0/0

#### 12. 域名绑定服务器

+ 单向绑定就可

+ 绑定方式同上，可以开个二级域名测试

  #### 13. 下载谷歌插件

  https://www.gugeapps.com

  jsonview







## 14. LAMP环境搭建及配置

​	linux + apache + mysql + php

​	时间较长

服务器都可以用命令操作的

默认是没有图形界面的，但是可以自个百度 安装图形界面 

centOS 图形界面



[来自阿里云官方论坛的文档](https://help.aliyun.com/document_detail/50774.html?spm=a2c4g.11186623.6.766.1fXGjs)

有经验的同学可以参考这个链接进行配置

​	https://help.aliyun.com/document_detail/50774.html?spm=a2c4g.11186623.6.766.1fXGjs

LAMP指Linux+Apache+MySQL/MariaDB+Perl/PHP/Python，是一组常用来搭建动态网站或者服务器的开源软件。它们本身都是各自独立的程序，但是因为常被放在一起使用，拥有了越来越高的兼容度，共同组成了一个强大的Web应用程序平台。

## 部署方式

您可以使用三种方式在云服务器ECS上部署LAMP：

- [镜像部署](https://help.aliyun.com/document_detail/25427.html)：方便快捷，适合不太了解Linux命令的用户。
- [一键安装包部署](https://help.aliyun.com/document_detail/44595.html)：适合对Linux命令有基本了解的用户。
- 手动部署：可以满足用户个性化部署需求，适合对Linux命令有基本了解的用户。

本文介绍如何在云服务器ECS上手动部署LAMP。

## 软件版本说明

本文操作的镜像和软件版本说明如下 ：

- 操作系统：CentOS 7.2 64位
- Apache：2.4.23
- MySQL：5.7.17
- PHP：7.0.12

## 前提条件

在部署之前，需要确认：

- 实例所在安全组已经 [放行了服务所需的端口](https://help.aliyun.com/document_detail/25471.html)：

  | 服务   | SSH    | HTTP   | MySQL    |
  | ---- | ------ | ------ | -------- |
  | 端口   | TCP 22 | TCP 80 | TCP 3306 |




有经验的同学可以参考这个链接进行配置

​	https://help.aliyun.com/document_detail/50774.html?spm=a2c4g.11186623.6.766.1fXGjs



重启Apache服务：

1. `/usr/local/apache/bin/apachectl restart`



1.  FTP上传（html | php）项目的目录

   `  /usr/local/apache/htdocs/`



## 学生优惠产品

https://promotion.aliyun.com/ntms/campus2017.html?spm=5176.8499797.959331.3.xLjpAv





# 第三节课 H5拖拽





**序言**

​		js里的拖拽三事件（mousedown、mousemove、mouseup）是做效果的，根据鼠标的移动位置让元素联动

​		而H5拖拽也能更加简单地实现，但更注重的是功能，例如，通过拖拽把网页上的元素删掉模拟电脑桌面上回收站的功能，也可以把电脑上的文件拖拽到网页里，可以获取文件的 名称、大小、时间等，和 qq邮箱、说说的上传图片、文件功能一样

​	**兼容**

​		网页的图片、选中文本，默认都可以拖拽，而其他元素默认是无法拖拽的，所以想拖拽元素就把开启拖拽元素的开关

> 谷歌下，在标签加上 draggable='true'
>
> 火狐下，在元素的拖拽事件的对象下面设置属性 e.dataTransfer.setData('key',value)

​	**事件**

​		*拖拽元素(被拖拽的元素)事件 :*  

```css
ondragstart : 	 拖拽的一瞬间触发 

ondrag	:		拖拽前、拖拽结束之间，连续触发

ondragend :		拖拽结束触发

```

​		*目标元素(拖拽元素被拖到的地方)事件 :*  

```css
ondragenter :	进入目标元素触发,鼠标光标进入

ondragover :	进入目标、离开目标之间，连续触发

ondragleave :	离开目标元素触发

ondrop : 		在目标元素上释放鼠标触发
```

​		*drop捕获事件*

> 默认状态下，一个元素不能放在另一元素的上面，需要在ondragover事件里面阻止默认事件
>
> ```js
> ele.ondragenter = function(e){
> 	e.preventDefualt();
>   	e.stopPropagation();
> }
> ele.ondragover = function(e){
> 	e.preventDefualt();
>   	e.stopPropagation();
> }
> ele.ondrop = function(e){
> 	e.preventDefualt();
>   	e.stopPropagation();
> }
> ```
>
> 这样才能让drop事件能够捕获到其它元素或文件

​		*函数*

​		只是简单的拖拽而没有交换是没有什么用的，所以为了在实现数据交换，提供了dataTransfer对象，它用于被拖拽元素放在目标元素的过程中传递字符串格式的数据



```js
设置数据 key和value (必须是字符串)
e.dataTransfer.setData('key',this.index);

获取数据 根据key值，获取对应的value
e.dataTransfer.setData('key');

拖拽元素的图标
e.dataTransfer.setDragImage(指定的元素，坐标X，坐标Y);
```



```js
files 	获取外部拖拽的文件，返回一个filesList列表
e.dataTransfer.files.length		获取文件长度
e.dataTransfer.files[index]		根据索引获取第几个文件
e.dataTransfer.files.item(i)	同上
e.dataTransfer.files[index].type	根据文件类型处理不同需求
e.dataTransfer.files[index].name	文件名称
e.dataTransfer.files[index].size	文件大小
e.dataTransfer.files[index].lastModifiedDate.toLocaleDateString()   文件上次修改时间戳，转换成日期
e.dataTransfer.files[index].lastModifiedDate.toLocaleTimeString()	文件上次修改时间对象，转换成时间

```





**读取文件对象**

​			FileReader API 用于读取文件，即把文件内容读入内存，是一种异步文件读取机制，它的参数是 File 对象或 Blob 对象。对于不同类型的文件，FileReader 提供不同的方法读取文件。



```javascript
创建读取文件的对象
var reader = new FileReader()	
分析文件对象
reader.readAsDataURL(files[0])

reader.onload = function(){
  console.log(this.result)
}
```





# 第四节课 arrayBuffer

## 元数据处理



## **1. 序言**

随着WebSocket、WebAudio、Ajax2等广泛应用，前端方面只要是处理大数据或者想提高数据处理性能，那一定是少不了 ArrayBuffer对象

同时在浏览器当中处理二进制数据的需求也在不断的增加，有时需要字节数组、8位、16位、32位整数型数组，所以对于JS中处理二进制迟早学习比较好

现今世界上几乎所有的计算机体系结构都是以字节（byte）为二进制数据的基本单位，所以二进制常常以字节数组的形式存在于程序当中

众所周知，JS是弱类型语言i，并且JS设计之初似乎根本没想过要处理二进制的东西，对于字节的概念可以说是非常非常的模糊。如果要表达字节数组，那么似乎只能用一个普通数组来表示

那么H5的诞生及标准的发布，对技术的革新起了非常大的作用，深入地研究H5，会渐渐发现，很多时候都会对二进制数据进行处理，结合JS的ArrayBuffer和 Typed Array去获取及处理音频数据、XHR2上传或下载二进制内容等等

## 2. arrayBuffer

`ArrayBuffer`表示二进制数据的原始缓冲区，该缓冲区用于存储各种类型化数组的数据。是最基础的原始数据容器，无法直接读取或写入， 需要通过其他方式来读写。 但可根据需要将其传递到类型化数组或 DataView 对象来解释原始缓冲区。

也就是说他是一个二进制数据的原始缓冲区，虽然 JavaScript 是弱类型语言，但是他本身是对数据的类型和大小都有限制的，我们`需要通过某种数据结构将缓冲区的内容有序的读取出来或写进去`

```css
例如：
Int8Array             8位有符号整数
Uint8Array            8位无符号整数
Uint8ClampedArray	  同上，像素操作
Int16Array            
Uint16Array
Int32Array
Uint32Array
Float32Array
Float64Array

以上是Typed Array类型化数组，类型化数组类型表示可编制索引和操纵的 ArrayBuffer 对象 的各种视图。 所有数组类型的长度均固定。而DataView视图对象对数据的操作更加细致

```

`ArrayBuffer`是一个固定长度的字节序列，通过`new ArrayBuffer(length)`来得到一片空间，内部实现与数组应该是不一样（内存分配和布局与Array不一样），`ArrayBuffer`是连续内存，因此对于高密度的访问（如音频数据）操作而言它比JS中的Array速度会快很多

`ArrayBuffer`是不能直接被访问的，因此需要借助Typed Array

Typed Array的背后是一个`ArrayBuffer`，也就是说，事实上的数据是存在`ArrayBuffer`里面的，而Typed Array只是给你提供了一个某种类型的读写接口

总结一句话:	Typed Array不直接存放任何数据，所有对Typed Array进行读写的操作，最终都会落实到它背后所持有的`ArrayBuffer`的身上。 `ArrayBuffer`才是真正的元始数据字节，而Typed Array只是一个操作窗口/操作视图（View）



## 3. 获取二进制数据



常见的在网页里获取二进制数据有三种:

> - [x] XMLHttpRequest2
> - [x] File
> - [x] Blob

​	**通过XMLHttpRequest 2**

​	`XHR2` 的接口跟 `XHR` 几乎是一样的，当制定`xhr.responseType = 'arraybuffer'`以后，在成功获取数据的回调里就可以通过`xhr.response`来得到请求结果的`ArrayBuffer`了，然后就可以按照你的意愿来构造各种Typed Array进行访问。

`responseType`还可以有`blob`取值，可以用`xhr.response`获得[Blob](https://developer.mozilla.org/en-US/docs/Web/API/Blob)对象。



​	**通过File和Blob**

​	在H5的表单File控件中，通过files对象来获取一个`FileList` ，此列表对象中的每一个都是files对象

​	也可以通过H5的拖拽drop事件捕获到files对象或blob对象

​	`File`继承了`Blob`，并提供了`name`  ， `lastModifiedDate`， `size` ，`type` 等基础元数据

​	`Blob` 与`ArrayBuffer`的区别是除了 原始字节 以外它还提供了mime type作为元数据

​	它们都可以借助 FileReader将`Blob`读取为更为实用的数据类型去使用

```css
readAsArrayBuffer()
readAsBinaryString()
readAsDataURL()
readAsText()
```



## 4. 各种类型



上节课中，我们讲过在火狐下拖拽元素需要用setData函数设置键值对，同时用getData函数可以获取key的value值，那么IE定义了 text和url 这两种有效的数据类型，可以获取本网页上文本和图片路径

> e.dataTransfer.getData('url')	获取 url

> e.dataTransfer.getData('Text')		获取文本

H5对此也支持，并扩展了各种 `MIME` 类型，这两种类型会被映射为 'text/plain'和'text/uri-list'

所以可以兼容一下:

```css
兼容
var dataTransfer = e.dataTransfer

获取 URL
var url = dataTransfer.getData('url') || dataTransfer.getData('text/uri-list')

获取 文本
var url = dataTransfer.getData('Text') || dataTransfer.getData('text/plain')
```



```css
MIME 类型
MIME (Multipurpose Internet Mail Extensions) 是描述消息内容类型的因特网标准。
MIME 消息能包含文本、图像、音频、视频以及其他应用程序专用的数据。

不同的应用程序支持不同的 MIME 类型。
MIME 类型大约有191种类型，是的没错，191种^.^
```

```css
Base64 类型
Base64是网络上最常见的用于传输8Bit字节码的编码方式之一，Base64就是一种基于64个可打印字符来表示二进制数据的方法
Base64编码是从二进制到字符的过程中，可用于在HTTP环境下传递较长的标识信息
```



**FileReader文件对象**

```css
FileReader API 用于读取文件，即把文件内容读入内存，是一种异步文件读取机制，它的参数是 File 对象或 Blob 对象。对于不同类型的文件，FileReader 提供不同的方法读取文件。
```

```css
创建读取文件的对象
var reader = new FileReader()	

readAsDataURL(Blob|File) 
读取文件并将文件以数据URI的形式保存在result属性中，返回一个基于 Base64 编码的 data-uri 对象
reader.readAsDataURL(files[0])

readAsText(Blob|File, opt_encoding)
返回文本字符串。默认情况下，文本编码格式是 UTF-8，可以通过可选的格式参数，指定其他编码格式的文本
以纯文本形式读取文件，将读取到的文本保存在result属性中，第二个参数用于指定编码类型，可选的
reader.readAsText( files[0],encoding )

readAsBinaryString(Blob|File)	IE可能不支持
返回二进制字符串，该字符串每个字节包含一个 0 到 255 之间的整数。（已废弃）
读取文件并将一个字符保存在result属性中，字符串的每个字符表示一字节
reader.readAsBinaryString(files)

readAsArrayBuffer(Blob|File)	IE可能不支持
返回一个 ArrayBuffer 对象
读取文件并将一个包含文件内容的ArrayBuffer保存在result属性中
reader.readAsArrayBuffer(files)
```



## 5. 具体用法



**FileList** 对象 

​		当用户通过 ***file 控件*** 选取文件后，这个控件的 this.files 属性值就是 FileList 对象。是个***类数组***，带上multiple 属性用户可选取多个文件，否则只能选择一个元素。

```js
<input type='file' multiple id='oInput'/>
<script>
    oInput.onchange = function() {
      	console.log(this.files)
    };
</script>
```

​		拖拽也可以获取  FileList 对象

```js
oInput.ondrop = function(e) {
    e.stopPropagation()
    e.preventDefault()
    var files = e.dataTransfer.files
    console.log(files)
  };
```

​		*在表单选择文件或者拖拽文件中，用户通过事件触发，只能被动地读取FileList 文件列表*



**Blob** 对象 

​		file对象的父类型是Blob对象， Blob对象代表了一段二进制数据，提供了一系列操作接口

​		生成 Blob 对象有两种方法：

> - [x] 使用 Blob 构造函数
> - [x] 另一种是对现有的 Blob 对象使用 slice 方法切出一部分

```js
Blob 构造函数，接受两个参数。
第一个参数是一个包含实际数据的数组
第二个参数是数据的类型
这两个参数都不是必需的

var arr = ["hello", "world"]
var Blob = new Blob(arr, { "type" : "text/xml" })
console.log(Blob)
```

```js
Blob 对象的 slice 方法，将二进制数据按照字节分块，返回一个新的 Blob 对象
var arr = ["hello", "world"]
var Blob = new Blob(arr, { "type" : "text/xml" })
var newBlob = Blob.slice(0, 5) ;  // 用在分片文件 ，后台接收把这些片段检验并组合一个文件
console.log(newBlob)

Blob 对象有两个只读属性：
size：二进制数据的大小，单位为字节。（文件上传时可以在前端判断文件大小是否合适）
type：二进制数据的 MIME 类型，全部为小写，如果类型未知，则该值为空字符串。（文件上传时可以在前端判断文件类型是否合适）
gbk编码：	数字字母 一字节 1KB= 1024字节 一中文汉字是 2字节
UTF-8编码： 数字字母 一字节 1KB= 1024字节 一个中文汉字是 3字节

```



​	**Silce** *读取部分内容*

​		有时候我们读取一部分而不是全部内容，Filereader对象支持一个slice( )方法，在火狐中用mozSlice( )，在chrome中webkitSilde( )

```css
	> silce( start,end )
	>
	> start 开始索引，默认为0
	>
	> end	截取结束索引（不包括end）
	> contentType	新Blob的MIME类型，默认为空字符串
```

​		这个方法返回一个Blob实例，Blog是File类型的父类型，Blog类型有一个size属性和一个type属性，它也支持slice方法，以便进一步切割数据，通过FileReader也可以从Blob中读取数据

```js
function blogSlice( blob,start,end ){
    if( blog.slice ){
		return blob.slice(start,end)
    }else if( blob.webkitSlice ){
      	return blob.webkitSlice(start,end)
    }else if( blob.mozSlice ){
    	return blob.mozSlice(start,end)         
    }else{
      	return null
    }
}
```

​	blob类型读取FileReader的20B内容 

```js
var reader = new FileReader()
var blob = blogSlice( e.dataTransfer.files[0] , 0 , 20 )
reader.readAsText( blob )
if( blob ){
   	reader.onload = function(){
		box.innerHTML = this.result
	}
}else{
  	alert('no data')
}

```

​	只读取文件的一部分可以节省时间，非常适合只关注数据中某个特定部分（如文件文件）的情况



​	**对象URL**	

​		对象URL也被称为 blob URL，指的是引用保存在File或Blob中数据的URL，使用对象URL的好处是没必要把内容读取到js中，而直接使用文件内容，能生成一个链接，例如 Img的src = URL

​		创建对象URL，用 window.URL.createObjectURL( blob )方法，并传入flle或Blob对象，对二进制数据生成一个 临时的URL，这个 URL 可以放置于任何通常可以放置 URL 的地方，比如 img 标签的 src 属性，出于一些特殊的需要，也可以使URL失效，调用 URL.revokeObjectURL( url ) 方法，使 URL 失效

```js
function createObject(blob){
  	if( window.URL ){
      	return window.URL.createObjectURL(blob)
  	}else if( window.webkitURL ){
      	return window.webkitURL.createObjectURL(blob)
  	}else{
      	return null
  	}
}
```

​	createObject函数的返回值是一个字符串，指向一块***内存地址***。因为这个字符串是URL，所 以在DOM中也能使用，例如下用法 

```js
var reader = new FileReader()
var url = createObject( files[0] )
if( url ){
  	if( /image/.test(files[0].type) ){
     	box.innerHTML = '<img src="'+url+'" />'
    }else{
      	alert( 'no img' )
    }
}else{
  	alert( 'no data' )
}
```

​	直接把对象URL放在img标签中，就省去了把数据先读取js中，另一方面img标签则会找到相应的内存地址，直接读取数据并将图像显示到页面中









# 第五节课



 在PC端有默认的返回前进按钮，移动端使用，app没有 默认 <- -> 是用标签模拟的，点击标签进行 前进或后退 或 刷新网页，只有 访问网页才有历史记录



## 1. 获取元素

```js
document.querySelector()  选择单个元素
document.querySelectorAll()  选择一组元素
参数 是 合法的 css选择器
静态的方法

document.getElementsByClassName() 通过类名选择
```



## 2. classList

```javascript
<div id="box" class="a b"></div>
    <input type="button" value="添加">
    <input type="button" value="删除">
    <input type="button" value="获取len">
    <input type="button" value="toggle">
    <input type="button" value="contains">

        // 可以通过 classList 对 class类名 增删改查
        let input = document.querySelectorAll('input');
		
		// 
		console.log( box.classList )
		// 增
        input[0].onclick = function () {
            // box.className = 'a b abc';
            console.log( box.classList )
            box.classList.add('abc','xyz');  // jq addClass()
            // 不能 add('a b')
        }
        // 删
        input[1].onclick = function () {
            // jq removeClass()
            box.classList.remove('abc')
        }
        input[2].onclick = function () {
            console.log( box.classList.length )
        }
        // 改
        input[3].onclick = function () {
            //  jq  toggleClass()
            box.classList.toggle('b');
        }
        
        // 查
        input[4].onclick = function () {
            // jq  hasClass()
            let c = box.classList.contains('xyz');
            console.log(c);
            c?(box.classList.remove('xyz')):(box.classList.add('xyz'));
        }

```



## 3. dataset

```javascript
<div id="box" data-a="自定义数据" data-a-basd-cgag="长名字" data-tpl-id="m_h_v31toutiao_default_1"></div>

// dataset 对自定义属性 增删改查
// 查
console.log(box.dataset);
console.log(box.dataset.a);
console.log(box.dataset['aBasdCgag']);
// 从第一个名字之后 都要驼峰命名法

// 改

box.dataset['a'] = '改变值';
box.setAttribute('data-abc-xyz','通过setAttr设置值')
console.log( box.getAttribute('data-a') )

// 删除
box.dataset['a'] = '';  // 没有值  属性就不存在
box.setAttribute('data-abc-xyz','');
box.removeAttribute('data-abc-xyz');

delete box.dataset['tplId']

// 框架 组件之间通信


```





##  3. parse-stringify



```javascript
parse() : 把字符串转成json
字符串中的属性要严格的加上引号
stringify() : 把json转化成字符串
会自动的把双引号加上


与eval的区别
	eval()：对任何的字符串进行解析变成js
	parse()：字符串中的属性要严格的加上引号
其他浏览器兼容
http://www.json.org/	去下载json2.js

// 后端返回的数据是字符串
        // 前端需要进行格式解析
        let arrStr = '["追梦",18]';
        let newArr = JSON.parse(arrStr);
        console.log(newArr);

        let json1 = '{ "name":"追梦","age":18 }';
        let json2 = `{
            "name":"追梦",
            "age":18
        }`;
        let newJson1 = JSON.parse(json2);
        console.log(newJson1)

        // 前端 要发起请求 携带数据 格式类型肯定是字符串
        let json3 = {
            name:"追梦",
            age:18
        }
        console.log( JSON.stringify(json3) );// 默认补上双引号

        let arr3 = ["追梦",18];
        console.log(JSON.stringify(arr3));
        // 很多东西你见过你学过 ，但是你知道 真实场景下 怎么运用吗？
        // 相对来说，不太安全 ， 只要是js语法结构 都可以当作js代码执行
        eval('alert(1);alert(1);alert(1);alert(1);');
        //sql注入
```



## 4. decodeURI-encodeURI

```javascript
let str = 'http://localhost:63342/05-%E6%96%B0%E5%A2%9E%E6%96%B9%E6%B3%95%E5%92%8C%E5%8E%86%E5%8F%B2%E7%AE%A1%E7%90%86/4-codeURL.html?_ijt=bm6ds8eevt24llnmhpsh5bgiaf';
        console.log(str)
        // 变成人能够认识的，要进行解码
        // 程序里的 函数  不光是前端有，其他语言也有
        let decodeD = decodeURI(str);  // 解码
        console.log( decodeD );
        // 编码 就是给计算机认识
        let newEncodeD = encodeURI(decodeD);  // 编码
        console.log(str);
```



## 5. atob-btoa

```javascript
 // 把 数据 编译成data base64编码
        // 这种字符串 好处在 减少http请求，不要大面积使用
        // 组成的成分 0-9 a-z A-Z + / = 64个字符
        let str = 'hello';
        // 把普通的字符串 转成  data base 64 数据
        let str1 = window.btoa(str); // 编码
        console.log(str1)

        let str2 = window.atob(str1);  // 解码
        console.log(str2)

        let str3 = 'hello追梦'; // 有[中文]不能够直接编码
        let uri = encodeURIComponent(str3); // 把中文进行编码
        console.log( window.btoa(uri) ); // 这时才能够编码

        let data = 'aGVsbG8lRTglQkYlQkQlRTYlQTIlQTY=';
        console.log( window.atob(data) ); // 编码
        let str4 = window.atob(data);
        console.log( decodeURIComponent(str4) ); // 解析人能够认识的数据
```





## 6. history 



```javascript
onhashchange  ：改变hash值来管理

history  ：历史管理
服务器下运行
pushState :  三个参数 ：数据  标题(都没实现)  地址(可选)
onpopstate事件 :  读取数据   event.state





// 既然历史记录，那我们可以根据历史记录 做些操作
        // 根据历史所存的数据  去渲染
        // 数据先行 数制驱动view
        // 理解在PC端使用
        let str = '';
        for (let key in data){
            str += '<li data-name="'+key+'">'+key+'</li>';
        }
        list.innerHTML = str;

        let aLi = document.querySelectorAll('li');
        aLi.forEach(function (item,index) {
            item.onclick = function () {
                //console.log( data[this.dataset['name']] );
                con.innerHTML = data[this.dataset['name']];
                //console.log( window.history );
                // 点击li  通过pustState函数把数据写入到 历史记录里面
                let a = decodeURI(this.dataset['name']);
                //console.log(a)
                if( window.history && window.history.pushState ){
                    window.history.pushState(a,'追梦','#abc='+a);
                }

            }
        })
        // 监听后退 前进 按钮
        window.onpopstate = function (e) {
            console.log(e.state)
            if( e.state ){
                con.innerHTML = data[e.state]; // 赋值
            }
        }
        window.onhashchange = function () {
            console.log( window.location.hash )
        }
```



## 7. back-forward-go



```javascript
// 移动端使用
        // app没有 默认 <- -> 是用标签模拟的
        // 点击标签进行 前进或后退 或 刷新网页
        // 只有 访问网页才有历史记录
        // 自己写三个网页
        /*
        *   第一个网页 有前进按钮 （点击进入 到第二个页面）
        *   第二个网页 有后退 前进按钮  点击后退 进入 第一个页面
        *   第三个网页 有后退   点击后退  可以进入到第二个页面，此时点击第二个页面的前进按钮，
        *   就能够进入 到第三个页面
        * */

history:
	
	back()  相当浏览器的后退按钮 
	
	go()  参数 0刷新  1下一页  -1上一页

     			forward( )   相当浏览器的前进按钮

```



























